"""Классы для описания нод пайплайна."""

from dataclasses import dataclass
from enum import Enum
from typing import Any, Optional


class PipelineObjectPrimitiveType(Enum):
    """Перечисление примитивных типов."""

    STR = ("str", str)
    INT = ("int", int)
    FLOAT = ("float", float)

    def py_type(self) -> type:
        """Соответствующий питоновский тип."""
        return self.value[1]  # noqa: WPS110

    @classmethod
    def from_string(cls, name: str) -> "PipelineObjectPrimitiveType":
        """Создает enum из строки."""
        for member in cls:
            if member.value[0] == name:
                return member
        raise ValueError(f"Unknown value for PipelineObjectPrimitiveType: {name}")


class PipelineObjectType(Enum):
    """Тип передаваемого объекта - строка или таблица."""

    ROW = "row"
    TABLE = "table"

    @classmethod
    def from_string(cls, name: str) -> "PipelineObjectType":
        """Создает enum из строки."""
        for member in cls:
            if member.value == name:
                return member
        raise ValueError(f"Unknown value for PipelineObjectType: {name}")


@dataclass
class PipelineObjectTypeConstraint:
    """Ограничение на передаваемый объект - строка/таблица + типы полей."""

    type: PipelineObjectType
    columns: dict[str, PipelineObjectPrimitiveType]

    def validate(self) -> None:
        """Валидирует объект."""
        assert len(self.columns) > 0, "PipelineObjectTypeConstraint.columns cannot be empty"

    @classmethod
    def from_raw_cfg(cls, raw_cfg: Any) -> Optional["PipelineObjectTypeConstraint"]:
        """Создаёт объект из словаря."""
        if raw_cfg is None:
            return None
        assert isinstance(raw_cfg, dict), "Raw config for PipelineObjectTypeConstraint need be dict"
        columns = raw_cfg.get("columns", {})
        constraint = cls(
            type=PipelineObjectType.from_string(raw_cfg["type"]),
            columns={col: PipelineObjectPrimitiveType.from_string(typ) for col, typ in columns.items()},
        )
        constraint.validate()
        return constraint


class PipelineNodeType(Enum):
    """Хранит тип ноды пайплайна."""

    DB_READ = "db_read"
    MERGER = "merger"
    AGGREGATOR = "agg"

    @classmethod
    def from_string(cls, name: str) -> "PipelineNodeType":
        """Создает enum из строки."""
        for member in cls:
            if member.value == name:
                return member
        raise ValueError(f"Unknown value for PipelineNodeType: {name}")


@dataclass
class PipelineNodeSpec:
    """Хранит описание ноды пайплайна."""

    name: str
    type: PipelineNodeType
    callback: str
    input: list[str]
    output: Optional[PipelineObjectTypeConstraint]

    def validate(self) -> None:
        """Валидирует объект."""
        if self.name == "":
            raise ValueError("Name cannot be empty")
        match self.type:
            case PipelineNodeType.DB_READ:
                return self._validate_db_read()
            case PipelineNodeType.MERGER:
                return self._validate_merger()
            case PipelineNodeType.AGGREGATOR:
                return self._validate_aggregator()
            case _:
                raise ValueError("Unknown PipelineNodeType in PipelineNodeSpec")

    @classmethod
    def from_raw_cfg(cls, node_name: str, raw_cfg: Any) -> "PipelineNodeSpec":
        """Создаёт объект из словаря."""
        assert isinstance(raw_cfg, dict), "Raw config for PipelineNodeSpec need be dict"
        spec = cls(
            name=node_name,
            type=PipelineNodeType.from_string(raw_cfg["type"]),
            callback=raw_cfg.get("callback", ""),
            input=raw_cfg.get("input", []),
            output=PipelineObjectTypeConstraint.from_raw_cfg(raw_cfg.get("output", None)),
        )
        spec.validate()
        return spec

    def _validate_db_read(self) -> None:
        if self.callback == "":
            raise ValueError("Callback for DB_READ cannot be empty")
        if len(self.input) == 0:
            raise ValueError("Input for DB_READ cannot be empty")
        if self.output is None:
            raise ValueError("Output for DB_READ cannot be empty")

    def _validate_merger(self) -> None:
        if self.callback != "":
            raise ValueError("Callback for MERGER is autogenerated")
        if len(self.input) == 0:
            raise ValueError("Input for MERGER cannot be empty")
        if self.output is not None:
            raise ValueError("Output for MERGE is autogenerated")

    def _validate_aggregator(self) -> None:
        if self.callback == "":
            raise ValueError("Callback for AGGREGATOR cannot be empty")
        if len(self.input) == 0:
            raise ValueError("Input for AGGREGATOR cannot be empty")
        if self.output is None:
            raise ValueError("Output for AGGREGATOR cannot be empty")
