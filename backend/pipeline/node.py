"""Классы для описания нод пайплайна."""

from dataclasses import dataclass
from enum import Enum
from typing import Any, Optional


class PipelineObjectPrimitiveType(Enum):
    """Перечисление примитивных типов."""

    STR = ("str", str)
    INT = ("int", int)
    FLOAT = ("float", float)

    def py_type(self) -> type:
        """Соответствующий питоновский тип."""
        return self.value[1]

    @classmethod
    def from_string(cls, value: str) -> "PipelineObjectPrimitiveType":
        """Создает enum из строки."""
        for member in cls:
            if member.value[0] == value:
                return member
        raise ValueError(f"Unknown value for PipelineObjectPrimitiveType: {value}")


class PipelineObjectType(Enum):
    """Тип передаваемого объекта - строка или таблица."""

    ROW = "row"
    TABLE = "table"

    @classmethod
    def from_string(cls, value: str) -> "PipelineObjectType":
        """Создает enum из строки."""
        for member in cls:
            if member.value == value:
                return member
        raise ValueError(f"Unknown value for PipelineObjectType: {value}")


@dataclass
class PipelineObjectTypeConstraint:
    """Ограничение на передаваемый объект - строка/таблица + типы полей."""

    type: PipelineObjectType
    columns: dict[str, PipelineObjectPrimitiveType]

    def validate(self) -> None:
        """Валидирует объект."""
        assert len(self.columns) > 0, "PipelineObjectTypeConstraint.columns cannot be empty"

    @classmethod
    def from_raw_cfg(cls, raw_cfg: Any) -> Optional["PipelineObjectTypeConstraint"]:
        """Создаёт объект из словаря."""
        if raw_cfg is None:
            return None
        assert isinstance(raw_cfg, dict), "Raw config for PipelineObjectTypeConstraint need be dict"
        constraint = cls(
            type=PipelineObjectType.from_string(raw_cfg["type"]),
            columns={
                col: PipelineObjectPrimitiveType.from_string(typ) for col, typ in raw_cfg.get("columns", {}).items()
            },
        )
        constraint.validate()
        return constraint


class PipelineNodeType(Enum):
    """Хранит тип ноды пайплайна."""

    DB_READ = "db_read"
    MERGER = "merger"
    AGGREGATOR = "agg"

    @classmethod
    def from_string(cls, value: str) -> "PipelineNodeType":
        """Создает enum из строки."""
        for member in cls:
            if member.value == value:
                return member
        raise ValueError(f"Unknown value for PipelineNodeType: {value}")


@dataclass
class PipelineNodeSpec:
    """Хранит описание ноды пайплайна."""

    name: str
    type: PipelineNodeType
    callback: str
    input: list[str]
    output: PipelineObjectTypeConstraint

    def validate(self) -> None:
        """Валидирует объект."""
        assert self.name != "", "Name cannot be empty"
        match self.type:
            case PipelineNodeType.DB_READ:
                assert self.callback != "", "Callback for DB_READ cannot be empty"
                assert len(self.input) > 0, "Input for DB_READ cannot be empty"
            case PipelineNodeType.MERGER:
                assert self.callback == "", "Callback for MERGER is autogenerated"
                assert len(self.input) > 0, "Input for MERGER cannot be empty"
                assert self.output is None, "Output for MERGE is autogenerated"
            case PipelineNodeType.AGGREGATOR:
                assert self.callback != "", "Callback for AGGREGATOR cannot be empty"
                assert len(self.input) > 0, "Input for AGGREGATOR cannot be empty"

    @classmethod
    def from_raw_cfg(cls, node_name: str, raw_cfg: Any) -> "PipelineNodeSpec":
        """Создаёт объект из словаря."""
        assert isinstance(raw_cfg, dict), "Raw config for PipelineNodeSpec need be dict"
        spec = cls(
            name=node_name,
            type=PipelineNodeType.from_string(raw_cfg["type"]),
            callback=raw_cfg.get("callback", ""),
            input=raw_cfg.get("input", []),
            output=PipelineObjectTypeConstraint.from_raw_cfg(raw_cfg.get("output", None)),
        )
        spec.validate()
        return spec
